# Сбор информации с страниц УИКов

Собрав ссылки на интересующие страницы УИКов, следующий шаг - извлечь информацию из них. При этом важно учесть, что обрабатываемая информация опубликована киррилицей, поэтому требуются средства, которые бы позволили сохранить читабельность названий ОИК, ТИК и УИК, к примеру. Для этого я использую функцию `GET` из пакета `{httr}`, а не другие имеющиеся инструменты. Получаемая с помощью этой функции структура страницы из Интернета представлена в `xml` формате, очень похожем на `html`, поэтому нужно подключить пакет `{xml2}`. Далее также понадобится пакет `{rvest}`, чтобы получить данные в виде текста. Полезным остаётся пакет `{stringr}`, с помощью которого можно очистить от лишнего переменные с набором знаков. Последние два пакета - `{dplyr}` и `{data.table}` - содержат полезные для объединения баз данных и их обработки функции.

```r
# install.packages("httr")
library(httr)
# install.packages("rvest")
library(rvest)
# install.packages("xml2")
library(xml2)
# install.packages("stringr")
library(stringr)
# install.packages("dplyr")
library(dplyr)
# install.packages("data.table")
library(data.table)
```

## Одномандатные округа

Работа с информацией по одномандатным округам в чём-то проще, но и сложнее тоже. На этапе сбора информации отсутствие презентации процента полученных голосов каждым кандидатом уменьшает количество производимых действий с помощью кода. При этом при обработке результатов, например, атрибуции результатов какого-либо кандидата с партией, к которой он принадлежит, нужно внимательно относится к разнице в количестве и порядке кандидатов на выборах в каждом ОИКе.

Шаги по превращению неудобных данных на сайте ЦИК РФ в рабочий вариант следующие:

1. Загрузка `.csv` файла с ссылками в рабочую среду. Это не требуется в случае если ранее этот файл уже был там (после скачивания ссылок на страницы УИК, например).

2. Сбор информации с `html`-страниц и её распознавание. Если адрес странички в Интернете введён в поле верно, то функция `GET{}` возвращает извлекаемый объект. Класс этого объекта - response (это можно узнать при введении `class(x)` с присвоенным ранее названием объекта `x`). Это значит, что пока что содержимое объекта нельзя извлечь следующим шагом. Чтобы извлечь объект необходимо условно "вытащить из коробки", поэтому далее следует расшифровать содержимое объекта при помощи функции `content{}`. Учитывая, что в данном случае приходится работать не с одним объектом, а более чем 3000, имеет смысл применить функцию `lapply{}` или же `Map{}`. Они позволяют применять одну и ту же функцию к ряду объектов, объединённых в вектор или список. Разница между ними небольшая.
```r
# sd_link = readRDS("Moscow_GD2016_SingleDistrict.Rds")
sd_results <- lapply(sd_urluik, GET) %>% Map(content,.)
```

3. В результате совершения предыдущего шага объект `sd_results` является списком, содержащим N элементов. Каждый из них - `xml`-документ, содержащий закодированную информацию с страницы. По-простому, это та же самая информация, просто в дополнение к ней в тексте можно встретить `<...>...</...>`. С помощью этих дополнительных знаков, или при учёте структуры страницы, можно получить нужную информацию. В браузере следует просмотреть исходный код страницы (инструменты разработчиков -> инспектор) и обозначить нужный элемент/узел (node). Вся информация, расположенная внутри этого узла, извлекается с помощью функции `xml_find_all{}`. Далее необходимо избавиться от узлов, так как информация более не представлена в виде структуры, что очень просто сделать функцией `html_text{}`.

```r
sd_obj <- lapply(sd_results, function(x) xml_find_all(x, ".//table//td")) %>% lapply(., html_text)
```

4. Предыдущий шаг возвращает объект `sd_obj` в виде списка списков. Каждый список содержит ряд знаковых элементов. Не стоит удивляться содержимому, типа `\r\n\t\t\t\r\n\t\t`, это всего лишь обозначения отступлений и переносов. Эти знаковые элементы необходимо перевести в переменные, которые содержатся в базе данных. Это самый сложный шаг в коде, и я долго пыталась преодолеть ограничения формулировки `lapply(seq_along(xs), function(i) {})`, однако, работающим решением оказался внешний указатель позиции элемента. Создаётся переменная `l`, которая содержит числа от одного до 3620 (именно столько элементов в списке `sd_obj`). К ней применяется луп `lapply{}`. В качестве применяемой функции можно ввести последовательность из нескольких с помощью "анонимной функции" ("лямбда функции" для пользователей Питона). Внутри нижеследующей анонимной функции происходит следующее: берётся n-ный элемент объекта `sd_df`, который соответствует числу из переменной `l` (оно соответствует номеру элемента в объекте `sd_obj` в свою очередь). Так как этот элемент, или список в списке, содержит ряд знаковых элементов, их нужно превратить в однострочную базу данных. Функция `unlist{}` превращает их в отдельные объекты, `rbind{}` - объединяет в ряд переменных (так как среди элементов нет таких, которые были бы не уникальными), а `data.frame{}` из матрицы переделывает получившийся объект в стандартный для `R` `data.frame`.

*Дисклеймер*: использование внешнего указателя не такая частая нужда, так как есть `lapply{}`, но когда-то давно он мне понадобился для совсем других нужд. Я не очень хорошо помню, но, кажется, я нашла это решение после долгих поисков на [Stack Overflow](https://stackoverflow.com/questions/tagged/r "Newest 'r' Questions - Stack Overflow"), а теперь не могу найти его снова. Вообще, хорошая штука - этот Stack Overflow.

```r
l <- 1:length(sd_results)
sd_df <- lapply(l, function(x) sd_obj[[x]] %>% unlist(.) %>% rbind(.) %>% data.frame(.))
```

5. Теперь есть список с рядом однострочных баз данных, но их нужно объединить в одну. Самый быстрый способ - использовать функцию `rbindlist{}` из пакета `{data.table}`. С её помощью за один шаг можно убить двух зайцев: извлечение из списка и объединение с помощью присоединения строчек. Аргумент `fill = T` предусматривает различную длину баз данных при одинаковом названии переменных (не в случае собираемой базы данных). Отсутствующее значение в переменной заполняется миссингом `NA`.

```r
sd_df <- rbindlist(sd_df, fill = T)
```

Voila, база данных с результатами выборов в ГД 2016 по одномандатным округам в Москве готова. Кириллица не пострадала, всё читается человеком. Для дальнейшего использования осталось только отобрать нужные переменные.

## Пропорциональная система

Похожие шаги нужно выполнить и при сборе результатов выборов по пропорциональной системе. Разница с одномандатными округами состоит в том, что там, где наряду с количеством поданных голосов указываются и проценты, код выше извлечёт их без опознания переноса на другую строку (элемент `<br>` в `html`-коде). Одно из решений - отобрать те элементы, в которых содержатся `<b>...</b>`, то есть количество поданных голосов без процентов. Эти поля далее будут дополнены информацией об УИК, ОИК, городе и любыми другими данными из общей таблицы. 

Код ниже я не буду комментировать, поскольку подробные объяснения были даны выше, а дополнительные отображаются в самом коде. 

```r
p_results <- lapply(p_urluik, GET) %>% Map(content,.)
l2 <- 1:length(p_results)
p_ndf_obj <- lapply(p_results, function(x) xml_find_all(x, ".//td//b")) %>% lapply(., html_text)
# здесь простое извлечение и соединение знаковых элементов в матрицу не подойдёт, дополнительно нужно транспонировать матрицу перед тем, как перевести её в формат базы данных
p_ndf <- lapply(l2, function(x) p_ndf_obj[[x]] %>% unlist(.) %>% t(.) %>% data.frame(.)) %>% rbindlist(., fill = T)
# далее повторение действий для сбора данных по одномандатным округам
p_rdf <- lapply(p_results, function(x) xml_find_all(x, ".//table//td")) %>% lapply(., html_text)
p_rdf <- lapply(l2, function(x) data.frame(rbind(unlist(p_rdf[[x]])))) %>% rbindlist(., fill = T)
```

Есть две базы данных с результатами выборов по пропорциональной системе. В одной содержатся непосредственно результаты, а в другой - все результаты, из которых потребуются только обозначения ОИК, районов и УИК. Я люблю использовать пакет `data.table{}`, поэтому для небольшой чистки перед объединением баз по пропорциональной системе и одномандатным округам.

```r
p_ndf <- data.table(p_ndf) %>% .[, c(4,6:8,13)]
p_rdf <- data.table(p_rdf) %>% .[, c(7)]
setnames(p_rdf,"X7","names")
p_rdf <- bind_cols(p_ndf,p_rdf)
```

Теперь можно объединить базы данных для пропорциональной системы и одномандатных округов в одну единую для всех выборов. Здесь тоже необходимо немного почистить названия переменных базы, так как названия переменных в них не совпадают.

```r
p_rdf <- p_rdf[,el_type:=rep("Пропорциональная",length(X4))]
setnames(p_rdf,c("X4","X6","X7","X8","X13"),c("line1","line3","line4","line5","line10"))
sd_df <- sd_df[,c(7,21,27,30,33,48)][,el_type:=rep("Одномандатный округ",length(X21))]
setnames(sd_df,c("X7","X21","X27","X30","X33","X48"),c("names","line1","line3","line4","line5","line10"))
# объединение в базу результатов выборов в Государственную Думу в 2016г. по партийным спискам и одномандатным округам
gd16_df <- bind_rows(p_rdf,sd_df)
```

Переменную `gd16_df$names` имеет смысл разделить на несколько с помощью, например, функции `separate{}` в пакете `{tidyr}`. 
```r
gd16_df <- tidyr::separate(gd16_df,names,c("odd","city","oik","district","uik"),sep = ">")
gd16_df <- select(gd16_df,-odd)
```

База готова к дальнейшей трансформации переменных или анализу на усмотрение исследователя.
